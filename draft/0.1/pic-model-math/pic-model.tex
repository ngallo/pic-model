\documentclass[11pt]{article}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{hyperref}

\title{Authority Propagation Models: PoP vs PoC and the Confused Deputy Problem}
\author{Nicola Gallo}
\date{1 December 2025}

\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}

\begin{document}
\maketitle

\section{Model}

We formalize the PIC (Provenance Identity Continuity) Model as follows.

Let $P$ be a finite set of principals, $O$ a set of operations, and $R$ a set of resources.
Define a privilege as $(o, r) \in O \times R$.

 ops_0), (p_1, ops_1), \dots, (p_n, ops_n) \rangle
Let $P$ be a set of principals (e.g., $U$, $PDF$, $Storage$).
Let $O$ be a set of operations (e.g., convert, delete),
\]
where $p_0$ is the originator and each $ops_{i+1} \subseteq ops_i$ (monotonicity).

\begin{definition}[PIC Model]
A system enforces Provenance Identity Continuity if, for every execution chain $\pi$,
the set of privileges at the final hop is bounded by the privileges at the origin:
\[
ops_n \subseteq ops_0
\]
and every privilege exercised at hop $n$ is causally linked to the origin via a verifiable chain.
\end{definition}

\begin{theorem}[PIC Safety]
If the PIC Model holds, no principal can exercise a privilege not present at the origin.
\end{theorem}

\begin{proof}
By construction, $ops_{i+1} \subseteq ops_i$ for all $i$, so $ops_n \subseteq ops_0$.
Thus, any $(o, r) \in ops_n$ must also be in $ops_0$.
Therefore, no privilege can be gained beyond the origin.
\end{proof}
and $R$ a set of resources.

A privilege is a pair $(o,r) \in O \times R$.
Each principal $p$ has a privilege set:
\[
Priv(p) \subseteq O \times R.
\]

A request is a message $req$ sent between principals and may contain a payload.

\section{Confused Deputy}

\begin{definition}[Confused Deputy]
A confused deputy occurs when there exist principals $U$ (user) and $D$ (deputy) such that:
\begin{enumerate}
    \item $(o,r) \notin Priv(U)$,
    \item $(o,r) \in Priv(D)$,
    \item $U$ sends a request $req$ to $D$,
    \item as a consequence of $req$, $D$ executes $(o,r)$.
\end{enumerate}
\end{definition}

This definition does not depend on implementation details,
only on the mismatch of authority and causality.

\section{Proof-of-Possession (PoP)}

A token $t$ grants a set of privileges:
\[
Auth(t) \subseteq O \times R.
\]

\paragraph{PoP Semantics:}
Possession implies usability:
if a principal holds $t$, it may exercise all $(o,r)\in Auth(t)$.

PoP systems do not constrain authority by causality or provenance.

\subsection{Vulnerability Condition}

Assume:
\begin{align}
&(\text{delete},r) \notin Priv(U) \tag{H1}\\
&(\text{delete},r) \in Priv(PDF) \tag{H2}
\end{align}

Further assume:

\begin{quote}
The payload of a request may influence control flow in $PDF$,
including code paths that call internal privileges such as delete.
\end{quote}

\begin{theorem}[PoP admits confused deputy]
Under assumptions (H1)--(H2), there exists a request $req^\*$ such that $PDF$
executes $(\text{delete},r)$ as a result of processing $req^\*$.
\end{theorem}

\begin{proof}
Since $(\text{delete},r)\in Priv(PDF)$ (H2), some code path in $PDF$ invokes
$\text{Storage.delete}(r)$.
Because processing is influenced by payload, there exists an adversarial payload
that triggers that path.
Since $U$ lacks $(\text{delete},r)$ (H1), and $PDF$ acts on behalf of $U$,
conditions for a confused deputy are satisfied.
\end{proof}

This applies to OAuth tokens and sealed capabilities:
sealing protects transport, not authority semantics.

\section{Proof-of-Continuity (PoC / PIC)}

Execution is modeled as a causal chain of hops:
\[
p_0 \rightarrow p_1 \rightarrow \dots \rightarrow p_n,
\]
with $p_0 = U$.

Each hop transfers a privilege subset:
\[
ops_i \subseteq O \times R
\]
and must satisfy:

\begin{equation}
ops_{i+1} \subseteq ops_i. \tag{C1}
\end{equation}

Let $\pi$ be a verifiable sequence:
\[
\pi = \langle (p_0,ops_0), (p_1,ops_1),\dots,(p_n,ops_n) \rangle.
\]

\subsection{Authorization Rule}
The final service authorizes $(o,r)$ if and only if:
\[
(o,r) \in \bigcap_{i=0}^{n} ops_i
\]
and $\pi$ is valid.

Since the chain is monotonic decreasing,
\[
\bigcap_{i=0}^{n} ops_i = ops_n.
\]

Thus no hop may acquire new authority not present at the origin.

\section{Safety Property}

\begin{definition}[Origin-bounded authority]
A model enforces origin-bounded authority if every executable privilege
at hop $n$ is a privilege originally granted by hop $0$.
\end{definition}

\begin{theorem}[PoC prevents confused deputy]
If $ops_0 = \{(\text{convert},r)\}$ and (C1) holds for every hop,
then $(\text{delete},r)$ can never be authorized at hop $n$.
\end{theorem}

\begin{proof}
Authorization requires:
\[
(\text{delete},r) \in \bigcap_{i=0}^{n} ops_i .
\]
But $(\text{delete},r)\notin ops_0$ and each $ops_{i+1}\subseteq ops_i$.
Therefore $(\text{delete},r)\notin ops_i$ for all $i$,
hence not in the intersection.
The request is rejected.
\end{proof}

\section{Discussion}

PoP systems conflate authority and possession, enabling confused deputy attacks
whenever privileged internal code paths exist.
PIC/PoC systems propagate only non-expansive subsets of authority,
ensuring that downstream services cannot perform operations not explicitly
authorized at the origin.

\section*{Related Work}

The confused deputy was originally formalized by Hardy (1988),
showing how ambient authority enables unintended privilege escalation.
Earlier foundations of capability systems date back to Dennis and Van Horn (1966),
while confinement and controlled execution were explored by Lampson (1973).
Modern capability systems such as EROS (Shapiro et al., 1999)
and seL4 (Klein et al., 2009) provide strong isolation properties and monotonic
privilege enforcement.
The formal theory of distributed authorization and delegation traces back to
Abadi et al. (1993--2000) and the SPKI certificate model (RFC 2693).
Recent identity systems such as BeyondCorp and SPIFFE apply similar causal
principles to zero-trust environments.

\section*{Acknowledgments}

The author used automated language assistance tools, including large language models,
to help with grammar, wording, and formal phrasing.
All ideas, models, proofs, and conclusions in this document are solely the 
responsibility of the author.

\section*{References}

\begin{enumerate}
\item N. Gallo.
   ``PIC Model â€” Provenance Identity Continuity for Distributed Execution Systems.''
   Zenodo (2025). \url{https://zenodo.org/records/17777421}.
   \label{gallo2025pic}

\item N. Hardy. ``The Confused Deputy (or why capabilities might have been
   better than addresses).'' \textit{Operating Systems Review}, 22(4), 1988.

\item J. B. Dennis and E. C. Van Horn.
   ``Programming Semantics for Multiprogrammed Computations.''
   \textit{Communications of the ACM}, 9(3), 1966.

\item B. W. Lampson.
   ``A Note on the Confinement Problem.''
   \textit{Communications of the ACM}, 16(10), 1973.

\item J. S. Shapiro, J. M. Smith, and D. J. Farber.
   ``EROS: A Fast Capability System.''
   \textit{Proceedings of the 17th ACM Symposium on Operating Systems Principles (SOSP)}, 1999.

\item G. Klein et al.
   ``seL4: Formal Verification of an OS Kernel.''
   \textit{Proceedings of the 22nd ACM Symposium on Operating Systems Principles (SOSP)}, 2009.

\item M. Abadi, M. Burrows, B. Lampson, and G. Plotkin.
   ``A Calculus for Access Control in Distributed Systems.''
   \textit{ACM Transactions on Programming Languages and Systems}, 1993--2000.

\item C. Ellison et al.
   ``SPKI Certificate Theory.'' RFC 2693, IETF, 1999.

\item Google.
   ``BeyondCorp: A New Approach to Enterprise Security.''
   Google Whitepaper, 2014.

\item SPIFFE Working Group.
   ``Secure Production Identity Framework for Everyone (SPIFFE).''

\end{enumerate}

\end{document}
